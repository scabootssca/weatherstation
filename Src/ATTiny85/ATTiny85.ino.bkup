// #include <avr/io.h>
// #include <util/delay.h>
// #include <avr/interrupt.h>
// #include <avr/pgmspace.h>

#include <SoftwareSerial.h>

// ATTiny Pins
#define RX_PIN PB2
#define TX_PIN PB1

//#define ESP_RESET_PIN PB2

//#define RAIN_BUCKET_PIN PCINT3
//#define ANEMOMETER_PIN PCINT4


// Serial comns
SoftwareSerial Serial(RX_PIN, TX_PIN);

// Sample Settings
#define ESP_WDT_TIMEOUT 30000

// Sample variables
volatile uint8_t previousInterruptPins = 0;
volatile unsigned long lastInterruptAnemometer = 0;
volatile unsigned long lastInterruptRainBucket = 0;

volatile unsigned char anemometerSampleCount = 0;
volatile unsigned char rainBucketSampleCount = 0;

volatile bool requestedSamples = false;
volatile unsigned long ledOnMillis = 0;

// Other variables
unsigned long lastEspContactMillis = 0;
unsigned long lastTickMillis = 0;
bool ledOn = false;


// 1 / 10.2677201193868 = samples per 1mph
#define ANEMOMETER_CALIBRATION_COEF 0.09739260404185239

void printBin(int pbyte) {
  for (int i=0;i<8; i++) {
    Serial.print((pbyte>>i)&1);
  }
  Serial.println();
}
//
// void resetEsp() {
//   // Set the reset pin as out and low then high then input
//   DDRB |= 1<<ESP_RESET_PIN; // output
//   PORTB &= ~(1<<ESP_RESET_PIN);  // low
//   delay(1);
//   PORTB |= (1<<ESP_RESET_PIN); // HIGH
//   delay(1);
//   PORTB &= ~(1<<ESP_RESET_PIN); // low
//   DDRB &= ~(1<<ESP_RESET_PIN); // input
//
//   // Restart the WDT
//   lastEspContactMillis = millis();
// }
//
// ISR(PCINT0_vect) {
//   // Get what chaged
//   uint8_t changedBits;
//   changedBits = PINB ^ previousInterruptPins;
//
//   // If the pin is changed and it was previously low
//   if (((changedBits>>ANEMOMETER_PIN)&1) && !((previousInterruptPins>>ANEMOMETER_PIN)&1)) {
//     if (millis()-lastInterruptAnemometer > 2) {
//       lastInterruptAnemometer = millis();
//       anemometerSampleCount++;
//       // PORTB |= 1<<ESP_RESET_PIN;
//       // ledOnMillis = millis();
//     }
//   }
//
//   if (((changedBits>>RAIN_BUCKET_PIN)&1) && !((previousInterruptPins>>RAIN_BUCKET_PIN)&1)) {
//     if (millis()-lastInterruptRainBucket > 2) {
//       lastInterruptRainBucket = millis();
//       rainBucketSampleCount++;
//       // PORTB |= 1<<ESP_RESET_PIN;
//       // ledOnMillis = millis();
//     }
//   }
//
//   // if (!requestedSamples && ((changedBits>>RX_PIN)&1) && !((previousInterruptPins>>RX_PIN)&1)) {
//   //   requestedSamples = true;
//   //   // PORTB |= 1<<ESP_RESET_PIN;
//   //   // ledOnMillis = millis();
//   // }
//
//   previousInterruptPins = PINB;
// }
//
// static inline void initInterrupt(void) {
//   // PCIE: Pin Change Interrupt Enable
//   GIMSK |= (1 << PCIE);
//
//   // Set pins to input
//   DDRB |= (1 << ANEMOMETER_PIN);
//   DDRB |= (1 << RAIN_BUCKET_PIN);
//   //DDRB |= (1 << RX_PIN);
//
//   // Enable interrupts for pins
//   PCMSK |= (1 << ANEMOMETER_PIN);
//   PCMSK |= (1 << RAIN_BUCKET_PIN);
//   //PCMSK |= (1 << RX_PIN);
//
//   // Save the start state
//   previousInterruptPins = PINB;
//
//   sei(); // Enable interrupts (Sets I flag (Bit 7) in SREG - AVR Status Register)
// }

void setup() {
  // Set pin modes and begin serial
  // DDRB &= ~(1<<RX_PIN);
  // PORTB &= ~(1<<RX_PIN);
  // DDRB |= (1<<TX_PIN);
  Serial.begin(9600);
  //Serial.listen();

  Serial.println();
  Serial.println("Initilizing ATtiny85");

  // Setup interrupts
  //initInterrupt();

  // Reset pin as in until we need it
  //DDRB &= ~(1<<ESP_RESET_PIN);

  // Request pin as input
  //DDRB &= ~(1<<RX_PIN);

  //DDRB |= (1<<ESP_RESET_PIN);
}

void loop() {

}
  // if (millis()-lastTickMillis > 100) {
  //     lastTickMillis = millis();
  //     ledOn = !ledOn;
  //
  //     if (ledOn) {
  //       PORTB |= (1<<ESP_RESET_PIN);
  //     } else {
  //       PORTB &= ~(1<<ESP_RESET_PIN);
  //     }
  // }
  //    Serial.println("Tick!");
  //  }
  // //   Serial.print("Tick; Wind: ");
  // //   Serial.print(anemometerSampleCount);
  // //   Serial.print(" Rain: ");
  // //   Serial.println(rainBucketSampleCount);
  // //   Serial.print("OnTime: ");
  // //   Serial.println(ledOnMillis);

  // // Turn off the led after 100ms
  // if (ledOnMillis && (millis() > ledOnMillis+100)) {
  //   ledOnMillis = 0;
  //   PORTB &= ~(1<<ESP_RESET_PIN);
  // }


  // while (Serial.available()) {
  //   Serial.read();
  // PORTB |= (1<<ESP_RESET_PIN);
  // delay(100);
  // PORTB &= ~(1<<ESP_RESET_PIN);
  // delay(100);
  //}

  // // If the request pin is high
  // if (requestedSamples) {
  //   cli();
  //   requestedSamples = false;
  //   unsigned char samples[2] = {anemometerSampleCount, rainBucketSampleCount};
  //   rainBucketSampleCount = 0;
  //   anemometerSampleCount = 0;
  //   sei();
  //
  //   lastEspContactMillis = millis();
  //
  //   Serial.write("~");
  //   Serial.write(samples[0]);
  //   Serial.write("!");
  //   Serial.write(samples[1]);
  //   Serial.write("\n");
  // }
  //
  // // Reset esp if not request in ESP_WDT_TIMEOUT
  // if (millis()-lastEspContactMillis > ESP_WDT_TIMEOUT) {
  //   Serial.println("Resetting ESP");
  //   resetEsp();
  // }
